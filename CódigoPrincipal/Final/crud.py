# -*- coding: utf-8 -*-
"""CRUD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f3pD6GyYOVhOWBDj0u1Jrf3ScAOVM2LE

#1. Imports
"""

!pip install pymongo
from pymongo import MongoClient
from google.colab import userdata
import datetime
from bson import ObjectId

!pip install bcrypt
import bcrypt

"""#1.1 Conectar"""

def conecta_user():
  STRING = "mongodb+srv://conecta-ia:O1r3VIK4X35CzEfL@conecta-cluster.hgjlsdc.mongodb.net/"
  try:
    client = MongoClient(STRING)
    db = client["conecta"]
    return db["user"]
  except Exception as e:
    print(f"Erro ao conectar ao MongoDB: {e}")
    return None

def conecta_token():
  STRING = "mongodb+srv://conecta-ia:O1r3VIK4X35CzEfL@conecta-cluster.hgjlsdc.mongodb.net/"
  try:
    client = MongoClient(STRING)
    db = client["conecta"]
    return db["token"]
  except Exception as e:
    print(f"Erro ao conectar ao MongoDB: {e}")
    return None

def conecta_ecommerce():
  STRING = "mongodb+srv://conecta-ia:O1r3VIK4X35CzEfL@conecta-cluster.hgjlsdc.mongodb.net/"
  try:
    client = MongoClient(STRING)
    db = client["conecta"]
    return db["ecommerce"]
  except Exception as e:
    print(f"Erro ao conectar ao MongoDB: {e}")
    return None

"""#2. Pessoas

##2.1 Usuário
"""

def criar_pessoa(nome: str, email: str, senha_plana: str):

    colecao = conecta_user()

    """
    Cria um novo usuário com senha segura

    Args:
        nome: Nome do usuário
        email: Email único para login
        senha_plana: Senha em texto plano (será hasheada)

    Returns:
        ID do documento inserido ou None em caso de erro
    """
    try:
        # Gerar hash da senha
        senha_hash = gerar_hash_senha(senha_plana)
        if not senha_hash:
            return None

        # Criar documento do usuário
        pessoa = {
            "nome": nome,
            "email": email,
            "senha": senha_hash,
            "created_at": datetime.datetime.utcnow(),
            "updated_at": datetime.datetime.utcnow()
        }

        # Inserir no banco de dados
        resultado = colecao.insert_one(pessoa)
        print(f"Usuário criado com ID: {resultado.inserted_id}")
        return resultado.inserted_id

    except Exception as e:
        print(f"Erro ao criar usuário: {e}")
        return None


def listar_pessoas():

  colecao = conecta_user()

  try:
    print("\nPessoas:")
    for pessoa in colecao.find().sort("codigo"):
      print("codigo: "+str(pessoa['codigo'])+" nome: "+pessoa['nome'])
    return True
  except Exception as e:
    print(f"Erro ao listar pessoas: {e}")
    return False


def buscar_por_id(id_str):
    try:
        obj_id = ObjectId(id_str)
        return colecao.find_one({"_id": obj_id})
    except:
        print("ID inválido")
        return None


def atualizar_pessoa(codigo: int, novo_nome: str):

  colecao = conecta_user()

  try:
    resultado = colecao.update_one(
    {"codigo": codigo},
    {"$set": {"nome": novo_nome}}
    )
    if resultado.modified_count > 0:
      print(f"Pessoa com código {codigo} atualizada com sucesso!")
      return True
    else:
      print(f"Nenhuma pessoa encontrada com código {codigo}")
      return False
  except Exception as e:
    print(f"Erro ao atualizar pessoa: {e}")
    return False


def deletar_pessoa(codigo: int):

  colecao = conecta_user()

  try:
    resultado = colecao.delete_one({"codigo": codigo})
    if resultado.deleted_count > 0:
      print(f"Pessoa com código {codigo} removida com sucesso!")
      return True
    else:
      print(f"Nenhuma pessoa encontrada com código {codigo}")
      return False
  except Exception as e:
    print(f"Erro ao deletar pessoa: {e}")
    return False

def autenticar_usuario(email: str, senha_plana: str) -> dict:

    colecao_pessoas = conecta_user()

    """
    Autentica um usuário com email e senha

    Args:
        email: Email do usuário
        senha_plana: Senha em texto plano

    Returns:
        Documento do usuário se autenticação for bem-sucedida, None caso contrário
    """
    try:
        # Buscar usuário pelo email
        usuario = colecao_pessoas.find_one({"email": email})
        if not usuario:
            print("Usuário não encontrado")
            return None

        # Verificar senha
        if verificar_senha(senha_plana, usuario["senha"]):
            print("Autenticação bem-sucedida!")
            return usuario
        else:
            print("Senha incorreta")
            return None

    except Exception as e:
        print(f"Erro ao autenticar usuário: {e}")
        return None

"""##2.2 Senha:"""

def atualizar_senha(email: str, senha_atual: str, nova_senha: str) -> bool:

    colecao = conecta_user()

    """
    Atualiza a senha de um usuário após verificação

    Args:
        email: Email do usuário
        senha_atual: Senha atual para verificação
        nova_senha: Nova senha a ser definida

    Returns:
        True se a atualização foi bem-sucedida, False caso contrário
    """
    try:
        # Primeiro autentica o usuário
        usuario = autenticar_usuario(email, senha_atual)
        if not usuario:
            return False

        # Gera novo hash
        novo_hash = gerar_hash_senha(nova_senha)
        if not novo_hash:
            return False

        # Atualiza no banco de dados
        resultado = colecao.update_one(
            {"_id": usuario["_id"]},
            {"$set": {
                "senha": novo_hash,
                "updated_at": datetime.datetime.utcnow()
            }}
        )

        return resultado.modified_count > 0

    except Exception as e:
        print(f"Erro ao atualizar senha: {e}")
        return False

def validar_forca_senha(senha: str) -> bool:
    """
    Valida a força de uma senha (mínimo de segurança)

    Args:
        senha: Senha a ser validada

    Returns:
        True se a senha atender aos requisitos mínimos
    """
    if len(senha) < 8:
        print("A senha deve ter pelo menos 8 caracteres")
        return False
    if not any(c.isupper() for c in senha):
        print("A senha deve conter pelo menos uma letra maiúscula")
        return False
    if not any(c.isdigit() for c in senha):
        print("A senha deve conter pelo menos um número")
        return False
    return True

def gerar_hash_senha(senha_plana: str) -> str:
    """
    Gera um hash seguro a partir de uma senha em texto plano

    Args:
        senha_plana: Senha em texto plano fornecida pelo usuário

    Returns:
        String com o hash da senha pronto para armazenamento
    """
    try:
        # Gera um salt aleatório
        salt = bcrypt.gensalt(rounds=12)  # rounds define o custo computacional (padrão é 12)

        # Cria o hash da senha
        hash_senha = bcrypt.hashpw(senha_plana.encode('utf-8'), salt)

        return hash_senha.decode('utf-8')  # Converte bytes para string

    except Exception as e:
        print(f"Erro ao gerar hash da senha: {e}")
        return None

def verificar_senha(senha_plana: str, hash_armazenado: str) -> bool:
    """
    Verifica se uma senha em texto plano corresponde ao hash armazenado

    Args:
        senha_plana: Senha fornecida para verificação
        hash_armazenado: Hash armazenado no banco de dados

    Returns:
        True se a senha estiver correta, False caso contrário
    """
    try:
        # Converte a string hash de volta para bytes
        hash_bytes = hash_armazenado.encode('utf-8')

        # Verifica a correspondência
        return bcrypt.checkpw(senha_plana.encode('utf-8'), hash_bytes)

    except Exception as e:
        print(f"Erro ao verificar senha: {e}")
        return False

"""#3. Token"""

def armazenar_token(user_id, messages):
    try:
        colecao_tokens = conecta_token()
        if colecao_tokens is None:
            return None

        token_data = {
            "user_id": user_id,
            "messages": messages, #Lista de dicionários com as mensagens no formato: [{"role": "user/bot", "content": "texto da mensagem"}, ...]
            "updated_at": datetime.datetime.utcnow()  # ISODate automático
        }

        resultado = colecao_tokens.insert_one(token_data)
        print(f"Token armazenado com ID: {resultado.inserted_id}")
        return resultado.inserted_id #ObjectId do documento inserido ou None em caso de erro
    except Exception as e:
        print(f"Erro ao armazenar token: {e}")
        return None

def buscar_tokens_por_usuario(user_id):
    try:
        colecao_tokens = conecta_token()
        if colecao_tokens is None:
            return None

        tokens = list(colecao_tokens.find({"user_id": user_id}).sort("updated_at", -1))
        return tokens  #Lista de tokens ou None em caso de erro
    except Exception as e:
        print(f"Erro ao buscar tokens: {e}")
        return None

"""#4. E-commerce"""

def cadastrar_ecommerce(nome: str, categoria: str, descricao: str, faixa_preco: int, url: str, plano: str, pros: str, contras: str):

    colecao = conecta_ecommerce()

    try:
        # Coletar dados do e-commerce
        print("\n--- Cadastro de E-commerce ---")
        ecommerce = {
            "_id": ObjectId(),  # Gerar um ObjectId automaticamente
            "name": nome,
            "category": categoria,
            "description": descricao,
            "faixa-preco": faixa_preco,
            "url": url,
            "plano": plano,
            "pros": pros,
            "contras": contras,
            "updated_at": datetime.datetime.utcnow()
        }

        def validar_url(url):
          try:
              result = urlparse(url)
              return all([result.scheme, result.netloc])
          except:
              return False

        # Inserir no banco de dados
        resultado = colecao.insert_one(ecommerce)
        print(f"\n✅ E-commerce cadastrado com ID: {resultado.inserted_id}")

        return resultado.inserted_id

    except ValueError:
        print("Erro: Rating deve ser um número entre 0 e 5")
        return None
    except Exception as e:
        print(f"Erro ao cadastrar e-commerce: {e}")
        return None


def listar_ecommerces():

    colecao = conecta_ecommerce()

    try:
        print("\n--- E-commerces Cadastrados ---")
        for ecom in colecao.find().sort("name"):
            print(f"\nID: {ecom['_id']}")
            print(f"\nNome: {ecom['name']}")
            print(f"Categoria: {ecom['category']}")
            print(f"Descrição: {ecom['description']}")
            print(f"Preço: {ecom.get('faixa-preco', 'Não informado')}")
            print(f"URL: {ecom.get('url', 'Não informada')}")
            print(f"Plano: {ecom.get('plano', 'Não informado')}")
            print(f"Pros: {', '.join(ecom.get('pros', []))}")
            print(f"Contras: {', '.join(ecom.get('contras', []))}")
            print(f"Atualizado em: {ecom['updated_at']}")

        return True

    except Exception as e:
        print(f"Erro ao listar e-commerces: {e}")
        return False

def buscar_ecommerce_por_id():

    colecao = conecta_ecommerce()

    try:
        id_ecommerce = input("Digite o ID do e-commerce: ")

        # Converter string para ObjectId
        from bson import ObjectId
        obj_id = ObjectId(id_ecommerce)

        ecommerce = colecao.find_one({"_id": obj_id})

        if ecommerce:
            print("\n🔍 E-commerce encontrado:")
            print(f"ID: {ecommerce['_id']}")
            print(f"Nome: {ecommerce['name']}")
            print(f"Categoria: {ecommerce['category']}")
            print(f"Descrição: {ecommerce['description']}")
            print(f"Faixa de preço: {ecommerce.get('faixa-preco', 'Não informado')}")
            print(f"URL: {ecommerce.get('url', 'Não informada')}")
            print(f"Plano: {ecommerce.get('plano', 'Não informado')}")
            print(f"Pros: {', '.join(ecommerce.get('pros', []))}")
            print(f"Contras: {', '.join(ecommerce.get('contras', []))}")
            print(f"Atualizado em: {ecommerce['updated_at']}")
            return ecommerce
        else:
            print("❌ Nenhum e-commerce encontrado com este ID")
            return None

    except Exception as e:
        print(f"Erro ao buscar e-commerce: {e}")
        return None

def buscar_ecommerces_por_categoria(categoria):

    colecao = conecta_ecommerce()

    return list(colecao.find({"category": categoria}))

def atualizar_ecommerce():

    colecao = conecta_ecommerce()

    try:
        id_ecommerce = input("Digite o ID do e-commerce a ser atualizado: ")

        # Verificar se o e-commerce existe
        from bson import ObjectId
        obj_id = ObjectId(id_ecommerce)
        ecommerce = colecao.find_one({"_id": obj_id})

        if not ecommerce:
            print("❌ E-commerce não encontrado")
            return False

        # Mostrar dados atuais
        print("\nDados atuais:")
        print(f"1. Nome: {ecommerce['name']}")
        print(f"2. Categoria: {ecommerce['category']}")
        print(f"3. Descrição: {ecommerce['description']}")
        print(f"4. Faixa de preço: {ecommerce.get('faixa-preco', 'Não informado')}")
        print(f"5. URL: {ecommerce.get('url', 'Não informada')}")
        print(f"6. Plano: {ecommerce.get('plano', 'Não informado')}")
        print(f"7. Pros: {', '.join(ecommerce.get('pros', []))}")
        print(f"8. Contras: {', '.join(ecommerce.get('contras', []))}")
        print(f"9. Atualizado em: {ecommerce['updated_at']}")


        # Coletar novos dados
        updates = {}
        campos = {
            '1': 'name',
            '2': 'category',
            '3': 'description',
            '4': 'faixa-preco',
            '5': 'url',
            '6': 'plano',
            '7': 'pros',
            '8': 'contras',
            '9': 'updated_at'
        }

        print("\nDigite os números dos campos que deseja atualizar (separados por vírgula):")
        campos_para_atualizar = input("Campos: ").split(',')

        for campo_num in campos_para_atualizar:
            campo_num = campo_num.strip()
            if campo_num in campos:
                if campo_num == '7':  # Pros é uma lista
                    updates[campos[campo_num]] = input(f"Novos pros (separadas por vírgula): ").split(',')
                elif campo_num == '8':  # Contras é uma lista
                    updates[campos[campo_num]] = input(f"Novos contras (separadas por vírgula): ").split(',')
                else:
                    updates[campos[campo_num]] = input(f"Novo {campos[campo_num]}: ")

        if updates:
            updates['updated_at'] = datetime.datetime.utcnow()
            resultado = colecao_ecommerce.update_one(
                {"_id": obj_id},
                {"$set": updates}
            )

            if resultado.modified_count > 0:
                print("✅ E-commerce atualizado com sucesso!")
                return True
            else:
                print("⚠️ Nenhum dado foi modificado")
                return False
        else:
            print("⚠️ Nenhum campo selecionado para atualização")
            return False

    except ValueError:
        print("Erro: Rating deve ser um número")
        return False
    except Exception as e:
        print(f"Erro ao atualizar e-commerce: {e}")
        return False


def deletar_ecommerce():

    colecao = conecta_ecommerce()

    try:
        id_ecommerce = input("Digite o ID do e-commerce a ser removido: ")

        from bson import ObjectId
        obj_id = ObjectId(id_ecommerce)

        # Confirmação antes de deletar
        confirmacao = input(f"Tem certeza que deseja deletar o e-commerce {id_ecommerce}? (s/n): ")
        if confirmacao.lower() != 's':
            print("Operação cancelada")
            return False

        resultado = colecao.delete_one({"_id": obj_id})

        if resultado.deleted_count > 0:
            print("✅ E-commerce removido com sucesso!")
            return True
        else:
            print("❌ Nenhum e-commerce encontrado com este ID")
            return False

    except Exception as e:
        print(f"Erro ao deletar e-commerce: {e}")
        return False

"""#5. Menu:"""

def menu():
    while True:
        print("\n--- MENU PRINCIPAL ---")
        print("1. Gerenciar Pessoas")
        print("2. Gerenciar E-commerces")
        print("3. Gerenciar Tokens")
        print("0. Sair")

        opcao = input("Escolha uma opção: ")

        if opcao == "1":
            menu_pessoas()
        elif opcao == "2":
            menu_ecommerces()
        elif opcao == "3":
            menu_tokens()
        elif opcao == "0":
            print("Saindo do sistema...")
            break
        else:
            print("Opção inválida! Tente novamente.")

def menu_ecommerces():
    while True:
        print("\n--- GERENCIAR E-COMMERCES ---")
        print("1. Cadastrar novo e-commerce")
        print("2. Listar todos e-commerces")
        print("3. Buscar e-commerce por ID")
        print("4. Atualizar e-commerce")
        print("5. Deletar e-commerce")
        print("0. Voltar")

        opcao = input("Escolha uma opção: ")

        if opcao == "1":
          nome = input("Digite o nome do e-commerce: ")
          categoria = input("Digite a categoria do e-commerce: ")
          descricao = input("Digite a descrição do e-commerce: ")
          faixa_preco = input("Digite a faixa de preço do e-commerce: ")
          url = input("Digite a URL do e-commerce: ")
          plano = input("Digite o plano do e-commerce: ")
          pros = input("Digite os pros do e-commerce (separados por vírgula): ").split(',')
          contras = input("Digite os contras do e-commerce (separados por vírgula): ").split(',')
          cadastrar_ecommerce(nome, categoria, descricao, faixa_preco, url, plano, pros, contras)

        elif opcao == "2":
            listar_ecommerces()

        elif opcao == "3":
            id_ecommerce = input("Digite o ID do e-commerce: ")
            buscar_ecommerce_por_id(id)

        elif opcao == "4":
            atualizar_ecommerce()

        elif opcao == "5":
            deletar_ecommerce()

        elif opcao == "0":
            break

        else:
            print("Opção inválida! Tente novamente.")

def menu_pessoas():
    while True:
        print("\n--- GERENCIAR PESSOAS ---")
        print("1. Criar nova pessoa")
        print("2. Login")
        print("3. Listar todas as pessoas")
        print("4. Buscar pessoa por id")
        print("5. Atualizar pessoa")
        print("6. Deletar pessoa")
        print("7. Alteral senha")
        print("0. Voltar")

        opcao = input("Escolha uma opção: ")

        if opcao == "1":
            nome = input("Nome completo: ")
            email = input("Email: ")
            while True:
                senha = input("Senha: ")
                if validar_forca_senha(senha):
                    break
                print("Por favor, crie uma senha mais forte.")
            criar_pessoa(nome, email, senha)

        elif opcao == "2":
            email = input("Email: ")
            senha = input("Senha: ")
            usuario = autenticar_usuario(email, senha)
            if usuario:
                print(f"Bem-vindo, {usuario['nome']}!")

        elif opcao == "3":
            listar_pessoas()

        elif opcao == "4":
            codigo = int(input("Digite o código para buscar: "))
            buscar_por_id(codigo)

        elif opcao == "5":
            codigo = int(input("Digite o código da pessoa a atualizar: "))
            novo_nome = input("Digite o novo nome: ")
            atualizar_pessoa(codigo, novo_nome)

        elif opcao == "6":
            codigo = int(input("Digite o código da pessoa a deletar: "))
            deletar_pessoa(codigo)

        elif opcao == "7":
            email = input("Email: ")
            senha_atual = input("Senha atual: ")
            nova_senha = input("Nova senha: ")
            if validar_forca_senha(nova_senha):
                if atualizar_senha(email, senha_atual, nova_senha):
                    print("Senha atualizada com sucesso!")
                else:
                    print("Falha ao atualizar senha. Verifique suas credenciais.")

        elif opcao == "0":
            break

        else:
            print("Opção inválida! Tente novamente.")

def menu_tokens():
    while True:
        print("\n--- GERENCIAR TOKENS ---")
        print("1. Armazenar token")
        print("2. Buscar tokens por usuário")
        print("0. Voltar")

        opcao = input("Escolha uma opção: ")

        if opcao == "1":
            user_id = input("Digite o ID do usuário: ")
            token = input("Digite o token: ")
            armazenar_token(user_id, token)

        elif opcao == "2":
            user_id = input("Digite o ID do usuário: ")
            buscar_tokens_por_usuario(user_id)

        elif opcao == "0":
            break

        else:
            print("Opção inválida! Tente novamente.")

menu()